<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class Schedule Heatmap</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        #map {
            height: 500px;
            width: 100%;
        }
        .controls {
            margin: 10px;
        }
    </style>
</head>
<body>
    <h1>Class Schedule Heatmap</h1>
    <div class="controls">
        <label for="day">Select Day:</label>
        <select id="day">
            <option value="Monday">Monday</option>
            <option value="Tuesday">Tuesday</option>
            <option value="Wednesday">Wednesday</option>
            <option value="Thursday">Thursday</option>
            <option value="Friday">Friday</option>
        </select>
        <label for="time">Select Time:</label>
        <input type="time" id="time" />
        <button id="submit">Submit</button>
    </div>
    <div id="map"></div>

    <script>
        // Initialize the map
        const map = L.map('map').setView([17.445, 78.349], 16); // Centered near the provided coordinates
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19
        }).addTo(map);

        // Load builds.geojson
        let locations = {};
        fetch('Builds.geojson')
            .then(response => response.json())
            .then(data => {
                data.features.forEach(feature => {
                    const name = feature.properties.name;
                    const coords = feature.geometry.coordinates;
                    locations[name] = { lat: coords[1], lng: coords[0] };
                });
            });

        // Function to calculate quantiles for classification
        const getQuantiles = (values, numClasses) => {
            values.sort((a, b) => a - b); // Sort values in ascending order
            const quantiles = [];
            for (let i = 0; i <= numClasses; i++) {
                const index = Math.floor((i / numClasses) * (values.length - 1));
                quantiles.push(values[index]);
            }
            return quantiles;
        };

        // Function to determine color based on classification
        const getColor = (value, thresholds, colors) => {
            for (let i = 0; i < thresholds.length - 1; i++) {
                if (value >= thresholds[i] && value <= thresholds[i + 1]) {
                    return colors[i];
                }
            }
            return colors[colors.length - 1]; // Default to the last color
        };

        // Function to add circles to the map
        const addCircles = (heatmapData, day, time) => {
            // Clear existing layers
            map.eachLayer(layer => {
                if (layer instanceof L.Circle) {
                    map.removeLayer(layer);
                }
            });

            // Aggregate data for the selected time and day
            const locationData = {};
            heatmapData.forEach(entry => {
                const schedule = entry.schedule[day]; // Get schedule for the selected day
                if (!schedule) return; // Skip if no schedule for this day

                schedule.forEach(slot => {
                    const [start, end] = slot.time.split('-').map(t => t.trim());
                    if (time >= start && time <= end) {
                        for (const [location, population] of Object.entries(slot.locations)) {
                            if (!locationData[location]) {
                                locationData[location] = { total: 0, classes: {} };
                            }
                            locationData[location].total += population;
                            locationData[location].classes[entry.class] = (locationData[location].classes[entry.class] || 0) + population;
                        }
                    }
                });
            });

            // Extract total populations for classification
            const populations = Object.values(locationData).map(d => d.total);
            const thresholds = getQuantiles(populations, 3); // 3 classes (adjustable)
            const colors = ['green', 'orange', 'red']; // Colors for each class

            // Add circles to the map
            for (const [location, data] of Object.entries(locationData)) {
                const color = getColor(data.total, thresholds, colors);
                if (locations[location]) {
                    L.circle(locations[location], {
                        color,
                        radius: 40 + data.total/10
                    }).addTo(map)
                      .bindPopup(`
                        <strong>${location}</strong><br>
                        Total Students: ${data.total}<br>
                        ${Object.entries(data.classes).map(([cls, count]) => `${cls}: ${count} students`).join('<br>')}
                      `);
                }
            }
        };

        // Load heatmap.json
        let heatmapData = [];
        fetch('heatmap.json')
            .then(response => response.json())
            .then(data => {
                heatmapData = data; // Load all class schedules
            });

        // Event listener for the submit button
        document.getElementById('submit').addEventListener('click', () => {
            const day = document.getElementById('day').value;
            const time = document.getElementById('time').value;
            if (day && time) {
                addCircles(heatmapData, day, time);
            } else {
                alert('Please select a day and time!');
            }
        });
    </script>
</body>
</html>
